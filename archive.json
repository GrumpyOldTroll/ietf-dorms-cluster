{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-07-22T01:42:47.198701+00:00",
  "repo": "GrumpyOldTroll/ietf-dorms-cluster",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOEmn6ks5E47lx",
      "title": "Ordering of sections (Digest before Manifest)",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/1",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It might be worth considering switching these sections as the digest is included inside the manifest, so explaining the larger structure first might make it easier. This can also be seen in the introduction, where a reference to 3.4 is made before a reference to 3.3 This also seems to be the convention in other RFCs. ",
      "createdAt": "2022-03-01T20:18:04Z",
      "updatedAt": "2025-05-06T16:19:23Z",
      "closedAt": "2025-05-06T16:19:23Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Sure, no objection.  I guess that makes sense.",
          "createdAt": "2022-03-16T22:01:06Z",
          "updatedAt": "2022-03-16T22:01:06Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOEmn6ks5E49EY",
      "title": "AMBI: Using the same term \"packet digest\" for two different things",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/2",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The fact that both the digest inside the manifest and the digest that is calculated from the individual packets is called \"packet digest\" can be quite confusing, especially in this sentence:\r\n\r\n> Upon receipt of a packet digest inside a manifest conveyed in a secure channel and verification that the packet digest of a received data packet matches, the receiver has proof of the integrity of the contents of the data packet corresponding to that digest.\r\n\r\nSo it might be good to find separate terms to make the differentiation between these two easier.",
      "createdAt": "2022-03-01T20:24:29Z",
      "updatedAt": "2025-05-16T12:40:52Z",
      "closedAt": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Maybe.  Any specific suggestions?  Maybe something like \"receiver-computed packet digest of the received data packet\"?\r\n\r\nI was thinking it made sense to use the same term because they're tightly coupled, since they're the same value if the transport was not corrupted.  I think different terms would be fine as long as their relatedness is still very clear.",
          "createdAt": "2022-03-16T21:56:04Z",
          "updatedAt": "2022-03-16T21:56:04Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOEmn6ks5E4_Nm",
      "title": "AMBI: Multicast-style efficiencies ",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/3",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In Section 2.1:\r\n\r\n> Note that a manifest contains potentially many packet digests, and its size can be tuned to fit within a convenient PDU (Protocol Data Unit) of the manifest transport stream.\r\nBy doing so, many packet digests for the multicast data stream can be delivered per packet of the manifest transport.\r\nThe intent is that even with unicast-based manifest transport, multicast-style efficiencies of scale can still be realized with only a relatively small unicast overhead, when manifests use a unicast transport.\r\n\r\nIs this referring to the overall transport of the content/data? It somewhat sounds like its referring to the manifest stream and it reaching multicast-style efficiencies, which I guess is not really the intended meaning. ",
      "createdAt": "2022-03-01T20:34:31Z",
      "updatedAt": "2025-05-16T12:40:46Z",
      "closedAt": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "I think this text is left over from when we were trying to combine this with ALTA, to put the manifests in an authenticated multicast stream.\r\n\r\nProbably this text is just unnecessary, or can be raised in a context like ALTA (when and if we get to it) where the size of a PDU of the manifest stream is a relevant concept.",
          "createdAt": "2022-03-16T21:36:54Z",
          "updatedAt": "2022-03-16T21:36:54Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOEmn6ks5E5CWP",
      "title": "AMBI: Hold down times/out of order packets",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/4",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Assume that a manifest gets significantly delayed  so the data packets sit and wait for their 2 second hold out. In the mean time, a manifest arrives that verifies newer packets. Shortly before the hold down time of the old packets runs out, the manifest arrives, verifying all packets that were waiting at once. This would lead to a burst of out-of order packets arriving at the application. To me that sounds like it could potentially cause trouble, as applications would need to take special precautions to deal with such bursts. \r\n\r\nConsidering there is focus on making sure manifests arrive before data packets, is there really any point in keeping data packets without a corresponding manifest around at all? Won't such packets be irrelevant for most multicast applications anyway if they only get verified 2 seconds after they arrive? ",
      "createdAt": "2022-03-01T20:50:53Z",
      "updatedAt": "2025-05-16T12:40:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Yes, good point.  I think this is not a sustainable requirement and we should remove it, as with the closely related #6.",
          "createdAt": "2022-03-16T21:33:02Z",
          "updatedAt": "2022-03-16T21:33:02Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOEmn6ks5E5C_R",
      "title": "AMBI: Duplicate section",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/5",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In 3.2.1:\r\n\r\n> Receivers MAY deviate from the values recommended by the sender for a variety of reasons, including their own memory constraints or local administrative configuration (for example, it might improve user experience in some situations to hold packets longer than the server recommended when there are receiver-specific delays in the manifest stream that exceed the server's expectations).\r\nDecreasing the buffering durations recommended by the server increases the risk of losing packets, but can be an appropriate tradeoff for specific network conditions and hardware or memory constraints on some devices.\r\n\r\nthen immediately following that:\r\n\r\n> Receivers SHOULD follow the recommendations for hold times provided by the sender (including the default values from the YANG model when unspecified), subject to their capabilities and any administratively configured overrides at the receiver.\r\n\r\nThis to me sounds like its saying the same thing (with the first one just being more specific), is there any need to keep both around?",
      "createdAt": "2022-03-01T20:54:24Z",
      "updatedAt": "2025-05-16T12:40:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "I think these are slightly different because the normative meaning of SHOULD imposes a soft requirement on receivers, whereas the normative meaning of MAY simply permits receiver behavior without implying any duty to do something different if possible.  So if we keep only one, we'd have to keep the second one, with the SHOULD, even though listing some example good reasons for a receiver to violate the SHOULD seems like worthwhile text to me.\r\n\r\nThat said, it's a fair point it seems pretty redundant, so maybe there's a cleaner way to phrase this that retains the SHOULD and the examples without sounding like it's repeating itself.",
          "createdAt": "2022-03-16T21:31:37Z",
          "updatedAt": "2022-03-16T21:31:37Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOEmn6ks5E5FIZ",
      "title": "AMBI: Inter-packet gap and delayed packets",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/6",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I am not sure how the interaction between delayed packets and keeping the inter packet gap works. Say a manifest gets delayed and some packets are buffered, when the manifest arrives does that mean that the gap is still kept? Wouldn't this in turn mean that any newly arriving packets are now delayed by the time the manifest was delayed as they also keep the inter-packet gap to the delayed packets? Wouldn't this delay also continuously increase with every delayed manifest? \r\n",
      "createdAt": "2022-03-01T21:04:13Z",
      "updatedAt": "2025-05-16T12:40:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "You are correct, this text should just be removed.  Good point.\r\n\r\n*Maybe* it's worth adding something to recommend that applications that depend on timing from on-path authenticators should do server-side buffering of the data packets to ensure the hashes will always arrive before the data, and that on-path authenticators should forward packets immediately upon authentication, but I'd expect anything performant enough to do that anyway, so maybe it doesn't need spelling out?\r\n\r\nBut yes, we should get rid of this part, thanks.",
          "createdAt": "2022-03-16T21:26:35Z",
          "updatedAt": "2022-03-16T21:26:35Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOEmn6ks5E5G9c",
      "title": "UDP payload length",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/7",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In section 3.3.1.1.1:\r\n\r\n> When the manifest definition is at the UDP layer, it applies only to packets with IP protocol of UDP (0x11) and the payload used for calculating the packet digest includes only the UDP payload with length as the number of UDP payload octets, as calculated by subtracting the size of the UDP header from the UDP payload length.\r\n\r\nShouldn't this say \r\n\r\n> [..] as calculated by subtracting the size of the UDP header from the _IP_ payload length.\r\n\r\nas the UDP payload length is inside the UDP header and already the desired number of UDP payload octets? ",
      "createdAt": "2022-03-01T21:11:14Z",
      "updatedAt": "2022-03-20T13:53:57Z",
      "closedAt": "2022-03-20T13:53:57Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "UDP's length value is the UDP header plus payload (https://datatracker.ietf.org/doc/html/rfc768):\r\n\r\n~~~\r\nLength  is the length  in octets  of this user datagram  including  this\r\nheader  and the data.   (This  means  the minimum value of the length is\r\neight.)\r\n~~~\r\n\r\nThe IP length value is the IP header plus IP payload, which can be larger than the UDP contents (this is the mechanism they're using for defining UDP options in the trailer space that's thus permitted to exist: https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-udp-options-15#section-3).\r\n\r\nIt's perhaps a good idea to consider more carefully whether this is the right set of data to authenticate, or whether other choices are needed.  Should there be an option to include the whole IP packet, particularly including IP options?  It's possible for an application to examine these, after all, so maybe wise to authenticate them?  But I wanted to allow for uses like mnat, which might actually discard these during an address translation step.  (It might even be possible for middle boxes to insert options, in general?)\r\n\r\nMy intent here was to allow for just authenticating the application layer data, which I think of as just the UDP payload.",
          "createdAt": "2022-03-16T21:22:10Z",
          "updatedAt": "2022-03-16T21:22:10Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, of course sorry about that! Closing this for now, can open again for your comment about scope.",
          "createdAt": "2022-03-20T13:53:57Z",
          "updatedAt": "2022-03-20T13:53:57Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOEmn6ks5E5Icx",
      "title": "Manifest identifier vs. manifest stream identifier",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/8",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Is there a difference between these two? If so, I dint think its made very clear what it is so far. ",
      "createdAt": "2022-03-01T21:18:22Z",
      "updatedAt": "2025-05-16T12:36:30Z",
      "closedAt": "2025-05-16T12:36:30Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Fair point, probably they should both be named manifest stream identifier.\r\n\r\nAs written, they're the same value in 2 different places (data packet pseudoheader vs. the manifest header).  There's a difference, but they both have the same value as an id in a manifest-stream-definition yang data object.",
          "createdAt": "2022-03-16T21:02:25Z",
          "updatedAt": "2022-03-16T21:02:25Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOEmn6ks5E5Jmh",
      "title": "AMBI: Explain handshake/parameters in text",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/9",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "While they are included in the YANG model, I think it would be a good idea to also explain the handshake and relevant parameters (hash-algorthim, hold times etc.) in the text itself. I think it just makes the documents more readable/ allows it even to be understood by people who aren't that versed with YANG. ",
      "createdAt": "2022-03-01T21:23:33Z",
      "updatedAt": "2025-05-16T12:40:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Yes, this is badly needed.  Good point, thanks for raising it.",
          "createdAt": "2022-03-16T22:02:18Z",
          "updatedAt": "2022-03-16T22:02:18Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOEmn6ks5GDQSk",
      "title": "AMBI: Collision attacks",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/11",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In section 8.1 it say\r\n\r\n> Protocols that have predictable packets run the risk of offline attacks for hash collisions against those packets. When authenticating a protocol that might have predictable packets, it's RECOMMENDED to use a hash function secure against such attacks\r\n\r\nI think this should be a requirement (not a recommendation) regardless of wether or not there are predictable packets. \r\n\r\nCan't any bad actor get access to the manifest stream? If so, they know the hash values that will be expected by the receivers. Given that manifests are supposed to be sent before the data packets, this might give them enough time to create packets that collide with the checksum, if a weak algorithm like MD5 is used, and send them. This means that the receivers could get inserted packets with matching checksums and authenticate them. Is there another mechanic I am missing that would prevent this? ",
      "createdAt": "2022-03-21T11:38:04Z",
      "updatedAt": "2025-05-16T12:40:04Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 15,
      "id": "I_kwDOEmn6ks6268bx",
      "title": "CBACC: Naming of Ingress meter",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/15",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Moving Jakes comments from I-D to issues:\n\nJake: Since nothing is necessarily being actively measured by a network component at the ingress, referring to the bitrate advertisement as an \"ingress meter\" for this context was considered confusing by reviewers, so the section was renamed with just a note pointing to the link. Likewise the egress meter and \"CB node\".",
      "createdAt": "2025-05-16T12:42:44Z",
      "updatedAt": "2025-05-16T13:47:15Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 16,
      "id": "I_kwDOEmn6ks6268z3",
      "title": "CBACC: better examples",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/16",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Jake: TBD: might need more and better examples explaining the point in [Section 2.1.5.1]? Some reason to believe it's not sufficiently clear...",
      "createdAt": "2025-05-16T12:43:23Z",
      "updatedAt": "2025-05-16T13:47:04Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 17,
      "id": "I_kwDOEmn6ks6268_n",
      "title": "CBACC: Operational Considerations section",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/17",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Jake: Another TBD: consider Dino's suggestion from 2020-04-09 to include an operational considerations section that addresses some possible optimizations for CB placement and configuration",
      "createdAt": "2025-05-16T12:43:44Z",
      "updatedAt": "2025-05-16T13:46:50Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 18,
      "id": "I_kwDOEmn6ks6269Qn",
      "title": "CBACC: RFC8084 coverage",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/18",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Jake:  TBD: add a section walking through the requirements in https://datatracker.ietf.org/doc/html/rfc8084#section-4 and explaining how this matches.",
      "createdAt": "2025-05-16T12:44:13Z",
      "updatedAt": "2025-05-16T13:46:40Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 19,
      "id": "I_kwDOEmn6ks6269hS",
      "title": "CBACC: RFC8407 applicability",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/19",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Jake: I'm unclear on whether https://datatracker.ietf.org/doc/html/rfc8407#section-3.8.2 applies here, such that providing an augmentation inside the DORMS namespace causes an update to the DORMS document.",
      "createdAt": "2025-05-16T12:44:40Z",
      "updatedAt": "2025-05-16T13:46:32Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 20,
      "id": "I_kwDOEmn6ks627XzK",
      "title": "DORMS: Make example use cases more explicit",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/20",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently the example use cases are a bit ambiguous/ it's not immediately clear why/how DORMS can solve them. Make it more explicit, e.g. state that information about expected bit rates could be provided by DORMS which in turn could be used for decision making. etc. ",
      "createdAt": "2025-05-16T13:28:05Z",
      "updatedAt": "2025-06-26T13:59:49Z",
      "closedAt": "2025-06-26T13:59:49Z",
      "comments": []
    },
    {
      "number": 21,
      "id": "I_kwDOEmn6ks627aYJ",
      "title": "DORMS: Channel discovery section",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/21",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "To me, the channel discovery section seems out of scope. Discovering SSM channels is not part of DORMS, so it might be better if we remove that section and simply state something akin to \"DORMS can in principal be used for any (S,G)\", which is largely already covered by Section 2.",
      "createdAt": "2025-05-16T13:32:16Z",
      "updatedAt": "2025-06-26T14:00:19Z",
      "closedAt": "2025-06-26T14:00:19Z",
      "comments": []
    },
    {
      "number": 22,
      "id": "I_kwDOEmn6ks627dXl",
      "title": "DORMS: Building issue/ YANG",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/22",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Also moving Jakes comments for Dorms from the DOC:\n\nJake:  building the draft without this line produces a warning about no reference to [[RFC6991](https://maxf12.github.io/ietf-dorms-cluster/draft-ietf-mboned-dorms.html#RFC6991)] or [[RFC8294](https://maxf12.github.io/ietf-dorms-cluster/draft-ietf-mboned-dorms.html#RFC8294)], but these are imported in the yang model. RFC 8407 requires the normative reference to 8294 (there's an exception for 6991 but I'm not sure why and it doesn't seem forbidden).",
      "createdAt": "2025-05-16T13:37:20Z",
      "updatedAt": "2025-07-04T13:10:41Z",
      "closedAt": "2025-07-04T13:10:41Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Seems to now build fine without this line ",
          "createdAt": "2025-06-26T14:53:19Z",
          "updatedAt": "2025-06-26T14:53:19Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "I_kwDOEmn6ks627dtg",
      "title": "DORMS: Non normative DNS expiry time",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/23",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Jake:  Although it's non-normative, I chose the boundaries in the recommendation for default setting of DNS expiry time in [Section 2.2]based on the best practices advice at https://www.varonis.com/blog/dns-ttl/ for \"Short\" and \"Long\" times.",
      "createdAt": "2025-05-16T13:37:55Z",
      "updatedAt": "2025-06-27T17:30:48Z",
      "closedAt": "2025-06-27T17:30:48Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think now that its in the ops considerations section its fine as is",
          "createdAt": "2025-06-26T14:54:23Z",
          "updatedAt": "2025-06-26T14:54:23Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOEmn6ks627eAw",
      "title": "DORMS: Section 7.1",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/24",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Jake: [Section 7.1] is intended to be the template from https://trac.ietf.org/trac/ops/wiki/yang-security-guidelines, as required by https://datatracker.ietf.org/doc/html/rfc8407#section-3.7. Individual nodes are not listed because blanket statements in that section covere them.",
      "createdAt": "2025-05-16T13:38:27Z",
      "updatedAt": "2025-07-04T13:10:35Z",
      "closedAt": "2025-07-04T13:10:35Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Seems fine as is",
          "createdAt": "2025-06-26T14:54:38Z",
          "updatedAt": "2025-06-26T14:54:38Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOEmn6ks627eM5",
      "title": "DORMS: Must constraint in group list",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/25",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Jake: The 'must' constraint in the group list seems awkward, but seems to work. Its intent is to require source & group to be either both IPv4 or both IPv6, without mixing & matching. It requires that either both the group address and its source parent's address must contain a colon or both must NOT contain a colon, where presence of a colon is used to distinguish IPv4 from IPv6. Maybe there's a better way?",
      "createdAt": "2025-05-16T13:38:46Z",
      "updatedAt": "2025-06-27T15:42:32Z",
      "closedAt": null,
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am not entirely sure what this is referring to?",
          "createdAt": "2025-06-26T14:53:59Z",
          "updatedAt": "2025-06-26T14:53:59Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "I think it was this:\nhttps://github.com/GrumpyOldTroll/ietf-dorms-cluster/blob/master/ietf-dorms.yang#L80",
          "createdAt": "2025-06-27T15:31:40Z",
          "updatedAt": "2025-06-27T15:31:40Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "IIRC there was a promising idea to somehow use the ipv4-address and ipv6-address typedefs from https://datatracker.ietf.org/doc/html/rfc6991, but I don't think I ever figured out the syntax (nor of course checked that it implements the intended requirement correctly).",
          "createdAt": "2025-06-27T15:42:32Z",
          "updatedAt": "2025-06-27T15:42:32Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOEmn6ks627iGl",
      "title": "DORMS: 2.2 Ignore List",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/26",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It seems to me that this is an implementation detail and doesn't need specification. ",
      "createdAt": "2025-05-16T13:45:18Z",
      "updatedAt": "2025-06-26T14:00:19Z",
      "closedAt": "2025-06-26T14:00:19Z",
      "comments": []
    },
    {
      "number": 27,
      "id": "I_kwDOEmn6ks63bz-3",
      "title": "DORMS: Privacy considerations",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/27",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think 5.2 is missing a case, where an on path observer can learn about the subscription of a client by seeing a packet to a known DORMS server, i.e. Source IP x sends packet to DORMS server y, so x is probably joined/wants to join one of the multicast streams y provides metadata for. This is probably minor. \n\nI also wonder if there is the possibility of a different mechanism that would preserve privacy better, e.g. instead of querying a server over unicast, instead we point to a separate (S,G) that just periodically broadcasts the relevant metadata. That would probably also help with scaling. This is of course only for the cases where the metadata is not required to be delivered over a secure channel, e.g. AMBI hashes.",
      "createdAt": "2025-05-20T15:57:31Z",
      "updatedAt": "2025-06-27T17:28:54Z",
      "closedAt": "2025-06-27T17:28:54Z",
      "comments": [
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "It's definitely a risk, especially if the DORMS server serves only DORMS requests and only serves such requests for a limited set of multicast content: from that you can deduce intent, even if the requests themselves are encrypted. This kind of traffic analysis for linkability can't be dealt with in a one-off manner, and is hardly unique to multicast. It really needs to be solved in aggregate, e.g., by using a single site to serve a large, heterogeneous set of content making it difficult to deduce the intent of any individual client without actually seeing the plaintext request. (If this isn't in the privacy considerations, it probably should be.)",
          "createdAt": "2025-06-27T17:28:29Z",
          "updatedAt": "2025-06-27T17:28:29Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOEmn6ks63b43K",
      "title": "DORMS: Editorial Nits",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/28",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Some slightly confusing sentences:\n- \"This supplemental information is sometimes needed by entities engaged in delivery or processing of the traffic to handle the traffic according to their requirements.\" \n- \"However, clients with out of band knowledge about the scope of the expected contents MAY issue requests for (S,G) metadata narrowed only by the source-address, or not narrowed at all.\"\n",
      "createdAt": "2025-05-20T16:04:28Z",
      "updatedAt": "2025-06-26T14:00:19Z",
      "closedAt": "2025-06-26T14:00:19Z",
      "comments": []
    },
    {
      "number": 32,
      "id": "I_kwDOEmn6ks7BpqEY",
      "title": "CBACC: Section 2.3.1",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/32",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently Section 2.3.1 is still missing, Brians comments from review: \n\nParallel to current discussions in SCONE, which is dealing with an adjacent\nproblem (throughput guidance for unicast flows to avoid traffic shapers, which\nare their own kind of single-point circuit breaker), the choice of a timescale\nis important when defining a trigger function, and I expect the currently TBD\nsection 2.3.1 will go into this in some detail when it is no longer TBD.",
      "createdAt": "2025-07-21T14:34:45Z",
      "updatedAt": "2025-07-21T14:34:45Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 33,
      "id": "I_kwDOEmn6ks7Bpq1T",
      "title": "CBACC: Better mapping to 8084",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/33",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From Brians review:\n\nThis document maps its concepts incompletely to the terminology of RFC\n8084, in a way that I found (as someone who also had to reread 8084 to complete\nthis review) found confusing. Pointedly 8084 assumes a feedback loop where the\negress meter (on the downstream end of a protected path) causes the ingress\nmeter to trigger when the circuit breaker trips, while this document seems to\nassume that the control point is at the egress meter. I'm not actually certain\nwhether this matters, since tripping downstream will eventually unload the\nupstream path. I also note that the authors note that other reviewers found the\n8084 terminology confusing. It probably makes sense for this document to note\nexplicitly that it is modifying the architectural assumptions in 8084\n(replacing an \"ingress meter\" with an ingress rate declaration via netconf, and\nmoving the control point forward)",
      "createdAt": "2025-07-21T14:35:44Z",
      "updatedAt": "2025-07-21T14:35:44Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 10,
      "id": "PR_kwDOEmn6ks40s3z_",
      "title": "Editorial changes",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/pull/10",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Some typos, reordering and of digest and manifest, renaming of manifest identifier to manifest stream identifier. \r\n\r\nCloses #1 and #8 ",
      "createdAt": "2022-03-20T13:56:36Z",
      "updatedAt": "2025-05-06T16:19:22Z",
      "baseRepository": "GrumpyOldTroll/ietf-dorms-cluster",
      "baseRefName": "master",
      "baseRefOid": "0ab9eb3b86da97ca159cd1ffed2a4dd6be3145c4",
      "headRepository": "MaxF12/ietf-dorms-cluster",
      "headRefName": "master",
      "headRefOid": "ad584407a48ba70b5851d68628eb22251befab29",
      "closedAt": "2025-05-06T16:19:22Z",
      "mergedAt": "2025-05-06T16:19:22Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "4b201c4c3f53783a97aa888dfc52330817b96273"
      },
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Now also trying to address the digest ambiguity.",
          "createdAt": "2022-03-20T14:51:15Z",
          "updatedAt": "2022-03-20T14:51:15Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's been long enough that we should just merge this and maybe the other PRs, and then just start editing from that point.",
          "createdAt": "2025-05-06T16:13:27Z",
          "updatedAt": "2025-05-06T16:13:27Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOEmn6ks402Jph",
      "title": "Refactor validation windows",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/pull/12",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #4, #5 and #6 ",
      "createdAt": "2022-03-22T23:42:38Z",
      "updatedAt": "2025-05-06T16:15:30Z",
      "baseRepository": "GrumpyOldTroll/ietf-dorms-cluster",
      "baseRefName": "master",
      "baseRefOid": "0ab9eb3b86da97ca159cd1ffed2a4dd6be3145c4",
      "headRepository": "MaxF12/ietf-dorms-cluster",
      "headRefName": "issue4and6",
      "headRefOid": "2a8df95ee09ec04d67a3a028292daa74f3afbbe7",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "If the consensus from #4 #5 and #6 was to remove the packet pacing preservation section, then this should be merged.",
          "createdAt": "2025-05-06T16:15:29Z",
          "updatedAt": "2025-05-06T16:15:29Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 13,
      "id": "PR_kwDOEmn6ks405d6s",
      "title": "First attempt at specifying the joining of a manifest stream",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/pull/13",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #9. I promise this is the last PR for now. Also please squash my commits, apparently I only realize how bad my text is when I see the diff on GitHub...\r\n\r\nAlso might need to change where the default times get mentioned, but I didn't want to crossover with #12 ",
      "createdAt": "2022-03-23T17:18:46Z",
      "updatedAt": "2022-03-23T17:20:01Z",
      "baseRepository": "GrumpyOldTroll/ietf-dorms-cluster",
      "baseRefName": "master",
      "baseRefOid": "0ab9eb3b86da97ca159cd1ffed2a4dd6be3145c4",
      "headRepository": "MaxF12/ietf-dorms-cluster",
      "headRefName": "issue9",
      "headRefOid": "7cec54387500ece6147b12cf67352f5b52eb8b5d",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 14,
      "id": "PR_kwDOEmn6ks43Mywd",
      "title": "Refactor collision attacks",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/pull/14",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "closes #11 ",
      "createdAt": "2022-05-03T00:29:02Z",
      "updatedAt": "2022-05-03T00:29:02Z",
      "baseRepository": "GrumpyOldTroll/ietf-dorms-cluster",
      "baseRefName": "master",
      "baseRefOid": "0ab9eb3b86da97ca159cd1ffed2a4dd6be3145c4",
      "headRepository": "MaxF12/ietf-dorms-cluster",
      "headRefName": "iss11",
      "headRefOid": "f75cd40a75dba1261c0d0bd269599f6f356c67ac",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 29,
      "id": "PR_kwDOEmn6ks6Zugqe",
      "title": "Issues 20, 21, 26 and 28",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/pull/29",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #20, #21, #26, #28 ",
      "createdAt": "2025-06-09T18:19:08Z",
      "updatedAt": "2025-06-26T13:59:48Z",
      "baseRepository": "GrumpyOldTroll/ietf-dorms-cluster",
      "baseRefName": "master",
      "baseRefOid": "b9f8db67f1c7ea9cdb3dfdfd9bfcf9fda12e0153",
      "headRepository": "MaxF12/ietf-dorms-cluster",
      "headRefName": "DormsGenIssues",
      "headRefOid": "6fc1159efcf14c8136934d628fa91db1d4f082f0",
      "closedAt": "2025-06-26T13:59:47Z",
      "mergedAt": "2025-06-26T13:59:47Z",
      "mergedBy": "squarooticus",
      "mergeCommit": {
        "oid": "e2715871f692e5017c7a4c54208d2e7d9bddd10f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEmn6ks6wHra0",
          "commit": {
            "abbreviatedOid": "91a064e"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-24T17:57:19Z",
          "updatedAt": "2025-06-24T17:57:19Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Not a huge deal, but one thing we'd been doing with these files is putting each sentence on its own line so diffs are more obvious and less likely to conflict. Since it's markdown, they get merged into a single paragraph when rendered, which makes this a useful pattern.",
              "createdAt": "2025-06-24T17:57:19Z",
              "updatedAt": "2025-06-24T17:57:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 30,
      "id": "PR_kwDOEmn6ks6cPyvT",
      "title": "Issue 27",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/pull/30",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #27 ",
      "createdAt": "2025-06-26T14:27:19Z",
      "updatedAt": "2025-06-27T17:28:53Z",
      "baseRepository": "GrumpyOldTroll/ietf-dorms-cluster",
      "baseRefName": "master",
      "baseRefOid": "e2715871f692e5017c7a4c54208d2e7d9bddd10f",
      "headRepository": "MaxF12/ietf-dorms-cluster",
      "headRefName": "27",
      "headRefOid": "cae69096650b1216e63a182fb3871d09310571f5",
      "closedAt": "2025-06-27T17:28:53Z",
      "mergedAt": "2025-06-27T17:28:53Z",
      "mergedBy": "squarooticus",
      "mergeCommit": {
        "oid": "8fc20fa6552cec5a341842afc99740e909136e66"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 31,
      "id": "PR_kwDOEmn6ks6cQGUO",
      "title": "Removal of in document issues",
      "url": "https://github.com/GrumpyOldTroll/ietf-dorms-cluster/pull/31",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Should close #23, #22 and #24, might need to take another look at #25.",
      "createdAt": "2025-06-26T14:57:07Z",
      "updatedAt": "2025-06-27T17:30:47Z",
      "baseRepository": "GrumpyOldTroll/ietf-dorms-cluster",
      "baseRefName": "master",
      "baseRefOid": "e2715871f692e5017c7a4c54208d2e7d9bddd10f",
      "headRepository": "MaxF12/ietf-dorms-cluster",
      "headRefName": "JakesIssues",
      "headRefOid": "05195f8eec77773fb78294d01a4ecabfbe0a5d74",
      "closedAt": "2025-06-27T17:30:47Z",
      "mergedAt": "2025-06-27T17:30:47Z",
      "mergedBy": "squarooticus",
      "mergeCommit": {
        "oid": "2672c53c8ce1474760e7a98893efc8fcfe8fd765"
      },
      "comments": [],
      "reviews": []
    }
  ]
}